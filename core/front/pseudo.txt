THIS PSEUDO CODE SIMULATES A SAMPLE SITUATION BUT IS NOT PSEUDO FOR GENERAL CASES (PROBABLY CODE FOR CONSOLE)
-------------------------------------------------------------------------------------------------------------

// 1 = wall
// 0 = open space
// LETS IN THIS CODE ARE JUST PLACEHOLDERS VARIABLE NAMES WILL VARY

let 2darray = [
    [ 0  0  0  0  0  0  0  0  0  0 ]
    [ 0  0  0  0  0  0  0  0  0  0 ]
    [ 0  0  0  1  1  0  0  0  0  0 ] 
    [ 0  0  0  1  1  1  0  0  0  0 ] 
    [ 0  0  1  1  1  1  1  0  0  0 ]
    [ 0  0  0  0  1  1  0  0  0  0 ]
    [ 0  0  0  0  0  0  0  0  0  0 ]
    [ 0  0  0  0  0  0  0  0  0  0 ] 
    [ 0  0  0  0  0  0  0  0  0  0 ] 
    [ 0  0  0  0  0  0  0  0  0  0 ]  
]


// returns length of 2d array, then we subtract 6 to get index of 5 for reference to the 5th row,
// then we get the length of the first row (does not matter which row because all rows have same 
// amount of items) in the 2d array, then we subtract one to get the index of the last item (the 10th one)
// which is an index of 9

let goalA = [len(2darray) -6, len(2darray[0] -1)




// cost function: f(n) = g(n) + h(n)

/* 
 * f(n) is cost
 * g(n) is cost for moving one step
 * h(n) is heuristic of (n)
*/

steps =>
1. compute heuristic model of grid
2. determine policies for each point based on cost


BUILDING HEURISTIC MODEL

// 2d array of possible moves
let delta = [
             [-1, 0] # go up
             [0, -1] # go left      
             [1, 0]  # go down     
             [0, 1]  # go right     
]
let delta_name = ['^', '<', 'v', '>']

ACTION

// return 2darray value that contains the heuristic steps to goal
//    ex: [14, 99, 12, 99, 10] [13, 99, 11, 99, 9] [12, 11, 10, 99, 8]
computeValue(grid, goal, cost) {
    let value = []
    value = 2darray
    value[0][0] = 99

    let visited = []
    let count = 0
    let x = goalA[0]
    let y = goalA[1]
    let point = [count, y, x]
    visited.append(point)
    let allChecked = false
    let index = 0
    count = 1
    while (!allChecked) {
        currentPoint =  visited[index]
        index++
        //populate neighbors
        neighborList = [];
        for (each move of delta) {
            newPoint = currentPoint + move // move in direction from delta
            if (newPoint is in grid, not barrier, and not already visited) {
                append newPoint to neighborList
            }
        }
    }
}